\chapter{カーネルのリモート・デバッグ}
この章では課題2で行った作業について説明する．
課題2ではgdb のリモート・デバッグ機能を用いて，カーネルのプログラムをデバッグ可能な状態にしステップ実行でシステムコールを追う．

\section{デバッグの準備}
まず，カーネルをVMware経由でデバッグするための準備を行う．
1章で行ったアドレスのランダム化の無効化やデバッグ情報の付加もデバッグのための準備の1つであった．
ここではVMwareの設定を中心に説明する．

まず，vimを使ってVMwareの.vmxファイルを直接編集する．
\begin{quote}
\$ cd 
\$ cd vmware/Ubuntu\ 64-bit/
\$ vim Ubuntu\ 64-bit.vmx
debugStub.listen.guest64 = "TRUE"
\end{quote}

debugStub.listen.guest64という項目をTRUEにする．
これによりポート8864番経由でgdbからリモートデバッグができるようになる．

\section{デバッグ対象の準備}
今回はrmdirというシステムコールの流れをgdbを使って追った．
rmdirはディレクトリを削除するときに呼ばれるシステムコールで，ユーザが意図的にシステムコールを呼ぶような操作を行わない限り
実行されないだろうという推測のもと選んだ．

デバッグ対象となる，rmdirを呼ぶアセンブリをリスト\ref{lst:rmdir}に示す．
\begin{longlisting}
\begin{myminted}{asm}{rmdir.s}
.intel_syntax noprefix
.global main

.LC1:
    .string "target_dir"

main:
    push rbp
    mov rbp, rsp

    mov rax, 84 # rmdir
    lea rdi, .LC1[rip]

    syscall

    mov rsp, rbp
    pop rbp
    ret
\end{myminted}
    \caption{rmdirを呼ぶアセンブリ}
\label{lst:rmdir}
\end{longlisting}

rmdirに割り当てられている番号は84番\cite{syscall}なのでraxに84を入れてsyscallを呼んでいる．
第一引数となるrdiレジスタには消去したいディレクトリ名を入れている．
このプログラムを実行するとシステムコールrmdirが呼ばれカレントディレクトリにある"target\_dir"というディレクトリが消される．

\section{gdbを用いたデバッグ}
準備ができたのでデバッグを行う．
gdbを起動して以下のコマンドを入力し，rmdirのエントリ関数にbreakpointを仕掛ける．
\begin{quote}
\$ gdb 
>>> file vmlinux
>>> target remote localhost:8864
>>> lx-symbols
>>> b \_\_x64\_sys\_rmdir 
>>> c
>>> b do\_rmdir 
\end{quote}

\$がターミナルのプロンプト，>>>はgdb内のプロンプトである．
まずgdbを起動し，vmlinuxを読み込む．
vmlinuxにはデバッグに必要なデバッグシンボルやシンボルテーブルが内包されていて，
カーネルをビルドしたディレクトリに置かれている．

次にリモートの対象を指定してアタッチする．
今回の場合は前述の通りlocalhostの8864番である．
アタッチできたらlx-symbolsでシンボルを読み込む．

ここまでで全ての準備が整ったのでシステムコールの流れを追っていく．
まずシステムコールの流れを追うためにはその処理を行っている入口にブレークポイントを張る必要がある．
対応表を見ると\_\_x64\_sys\_rmdirにブレークポイントを張れば良いことが分かる．\cite{syscall}
ブレークポイントを張ったら一度c(continue)で飛ぶ．
るとrmdirの処理を行うdo\_rmdirが見つかるのでそこにブレークポイントを仕掛ける．

\begin{quote}
>>> c
（省略）
─── Stack ──────────────────────────────────────────────────────────────
[0] from 0xffffffff8121dfa9 in getname_flags+57 at fs/namei.c:128
[1] from 0xffffffff8121f121 in getname+16 at fs/namei.c:4099
[2] from 0xffffffff8121f121 in __do_sys_rmdir+16 at fs/namei.c:4099
>>> p filename
\$1 = 0x5651805ae129 "target_dir"
\end{quote}

do_rmdirに飛ぼうとするとまず関数getnameの中のgetname_flagsに入る．
これはdo_rmdirの引数に関数getnameが入っているからでここでディレクトリ名を取得する．

ディレクトリ名の取得が終わるとdo_rmdirの本体に入る．
\begin{quote}
（省略）
>>> c
─── Stack ──────────────────────────────────────────────────────────────
[0] from 0xffffffff8121ef60 in do_rmdir+0 at fs/namei.c:4038
[1] from 0xffffffff8121f12e in __do_sys_rmdir+29 at fs/namei.c:4099
─── Source ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 4042      struct path path;
 4043      struct qstr last;
 4044      int type;
 4045      unsigned int lookup_flags = 0;
 4046  retry:
 4047      error = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
>>> p filename
\$1 = 0x5651805ae129 "target_dir"
>>> p *name
\$2 = {
  name = 0xffff888100815020 "target_dir",
  uptr = 0x7ffd72acf92a "target_dir",
  refcnt = 1,
  aname = 0x0 <fixed_percpu_data>,
  iname = 0xffff888100815020 "target_dir"
}
>>> p dfd
\$3 = -100
\end{quote}

rmdirに入って最初に到達するのは4047行目である．
filename_parentatという関数が見えるので中に入ってみる．
\begin{quote}
\end{quote}
─── Source ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 2572      if (unlikely(retval == -ESTALE))
 2573          retval = path_parentat(&nd, flags | LOOKUP_REVAL, parent);
 2574      if (likely(!retval)) {
 2575          *last = nd.last;
 2576          *type = nd.last_type;
 2577          audit_inode(name, parent->dentry, AUDIT_INODE_PARENT);
 2578      }
 2579      restore_nameidata();
 2580      return retval;
 2581  }
─── Stack ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[0] from 0xffffffff8121bbb9 in filename_parentat+265 at fs/namei.c:2577
[1] from 0xffffffff8121efa1 in do_rmdir+65 at fs/namei.c:4047

最適化の関係かいきなり途中に飛ばされた．
最適化とマクロの都合で急に飛ばされるのでソースと照らし合わせて確認すると，ここでは最終的に__audit_inodeにたどり着き親のエントリ
のinodeをチェックしていた．

do_rmdirにまで戻って返り値の確認をする．
\begin{quote}
>>> n
─── Source ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 4043      struct qstr last;
 4044      int type;
 4045      unsigned int lookup_flags = 0;
 4046  retry:
 4047      error = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
 4048      if (error)
 4049          goto exit1;
 4050
 4051      switch (type) {
 4052      case LAST_DOTDOT:
─── Stack ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[0] from 0xffffffff8121efa4 in do_rmdir+68 at fs/namei.c:4048
[1] from 0xffffffff8121f12e in __do_sys_rmdir+29 at fs/namei.c:4099
>>> p error
\$9 = 0
>>> p type
\$12 = 0
>>> p last
\$13 = {
  {
    {
      hash = 3336219575,
      len = 10
    },
    hash_len = 46285892535
  },
  name = 0xffff888100815020 "target_dir"
}
\end{quote}

返り値errorは0だった．
パスの親のチェックは正常に完了したようだ．
次に進む．

\begin{quote}
>>> n
─── Source ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 4058      case LAST_ROOT:
 4059          error = -EBUSY;
 4060          goto exit2;
 4061      }
 4062
 4063      error = mnt_want_write(path.mnt);
 4064      if (error)
 4065          goto exit2;
 4066
 4067      inode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);
─── Stack ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[0] from 0xffffffff8121f016 in do_rmdir+182 at fs/namei.c:4063
[1] from 0xffffffff8121f12e in __do_sys_rmdir+29 at fs/namei.c:4099
>>> p *path.mnt
\$16 = {
  mnt_root = 0xffff88810519cd80,
  mnt_sb = 0xffff888104777000,
  mnt_flags = 4128,
  mnt_userns = 0xffffffff8284ec80 <init_user_ns>
}
>>> s
\end{quote}

mnt_want_writeという関数を呼んでいるので確認してみる．
これはマウントするための書き込みのアクセスを取得するための関数らしい．
本体は__mnt_want_writeで権限などのチェックを行っていた．

ディレクトリを実際に消去する関数を見てみる．
\begin{quote}
（省略）
>>> n
─── Source ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 4075      }
 4076      error = security_path_rmdir(&path, dentry);
 4077      if (error)
 4078          goto exit4;
 4079      mnt_userns = mnt_user_ns(path.mnt);
 4080      error = vfs_rmdir(mnt_userns, path.dentry->d_inode, dentry);
 4081  exit4:
 4082      dput(dentry);
 4083  exit3:
 4084      inode_unlock(path.dentry->d_inode);
─── Stack ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[0] from 0xffffffff8121f06f in do_rmdir+271 at fs/namei.c:4080
[1] from 0xffffffff8121f12e in __do_sys_rmdir+29 at fs/namei.c:4099
>>> p mnt_userns
\$8 = (struct user_namespace *) 0xffffffff8284ec80 <init_user_ns>
>>> p path.dentry->d_inode
\$9 = (struct inode *) 0xffff888126faa950
>>> p dentry
\$10 = (struct dentry *) 0xffff88801da7d600
\end{quote}

vfs_rmdirで処理を行っているようなので確認する．

vfs_rmdirをリスト\ref{lst:vfs}に示す．
\begin{longlisting}
\begin{myminted}{c}{}
int vfs_rmdir(struct user_namespace *mnt_userns, struct inode *dir,
         struct dentry *dentry)
{
	int error = may_delete(mnt_userns, dir, dentry, 1);

	if (error)
		return error;

	if (!dir->i_op->rmdir)
		return -EPERM;

	dget(dentry);
	inode_lock(dentry->d_inode);

	error = -EBUSY;
	if (is_local_mountpoint(dentry) ||
	    (dentry->d_inode->i_flags & S_KERNEL_FILE))
		goto out;

	error = security_inode_rmdir(dir, dentry);
	if (error)
		goto out;

	error = dir->i_op->rmdir(dir, dentry);
	if (error)
		goto out;

	shrink_dcache_parent(dentry);
	dentry->d_inode->i_flags |= S_DEAD;
	dont_mount(dentry);
	detach_mounts(dentry);

out:
	inode_unlock(dentry->d_inode);
	dput(dentry);
	if (!error)
		d_delete_notify(dir, dentry);
	return error;
}
\end{myminted}
\caption{vfs_rmdir()}
\label{lst:vfs}
\end{longlisting}

may_deleteでまずディレクトリを消去可能かをチェックし，
inodeのrwsemを0にしてinodeをlockする．
その後， security_inode_rmdir，dir->i_op->rmdirを試す．
\begin{quote}
    ─── Source ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 3999      int error = may_delete(mnt_userns, dir, dentry, 1);
 4000
 4001      if (error)
 4002          return error;
 4003
 4004      if (!dir->i_op->rmdir)
 4005          return -EPERM;
 4006
 4007      dget(dentry);
 4008      inode_lock(dentry->d_inode);
─── Stack ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[0] from 0xffffffff81219723 in vfs_rmdir+35 at fs/namei.c:4004
[1] from 0xffffffff8121f07f in do_rmdir+287 at fs/namei.c:4080
>>> p dir->i_op->rmdir
\$1 = (int (*)(struct inode *, struct dentry *)) 0xffffffff812ef410 <ext4_rmdir>
\end{quote}
デバッガで追ったときはsecurity_inode_rmdirではなく，dir->i_op->rmdirで消去を実行した．
dir->i_op->rmdirの正体はfs/ext4/namei.cにあるext4_rmdirだった．
\begin{quote}
─── Source ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 3065      if (unlikely(ext4_forced_shutdown(EXT4_SB(dir->i_sb))))
 3066          return -EIO;
 3067
 3068      /* Initialize quotas before so that eventual writes go in
 3069       * separate transaction */
 3070      retval = dquot_initialize(dir);
 3071      if (retval)
 3072          return retval;
 3073      retval = dquot_initialize(d_inode(dentry));
 3074      if (retval)
─── Stack ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[0] from 0xffffffff812ef452 in ext4_rmdir+66 at fs/ext4/namei.c:3070
[1] from 0xffffffff812197e4 in vfs_rmdir+178 at fs/namei.c:4019
\end{quote}

fs/ext4/namei.cにあるext4_rmdirでディレクトリを消去した後，inodeのlockを解き処理は終了する．
追っていけばキリが無いが単にディレクトリを消すだけでもこれだけたくさんの処理が走っていることが分かった．

